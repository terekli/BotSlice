import numpy as npdef build_contours(connected_points):    contours = []  # List to accumulate all contour points        # Remove entries that are triangle or single point    connected_points = [entry for entry in connected_points if entry.shape != (1, 2) and entry.shape != (3, 2)]        # Function to add a point if it's not the same as the last one added    def add_point_if_new(point, contour_list):        if not contour_list or not np.allclose(contour_list[-1], point, atol=0.005):            contour_list.append(point)        # Pre-process to separate edges and triangles    try:        edges = [entry for entry in connected_points if entry.shape[0] == 2]        triangles = [entry for entry in connected_points if entry.shape[0] == 3]    except:        a = 1        # Triangles are added directly, each triangle forms a closed contour    for tri in triangles:        for point in tri:            add_point_if_new(point, contours)        # Process edges to form contours    while edges:        edge = edges.pop(0)  # Take the first edge to start a new contour        current_contour = [edge[0]]  # Start with the first point of the first edge        add_point_if_new(edge[1], current_contour)  # Add the second point if it's new                # Try to extend the contour by finding connecting edges        was_extended = True        while was_extended:            was_extended = False            for i, next_edge in enumerate(list(edges)):  # Iterate over a copy of edges to safely remove items                if np.allclose(next_edge[0], current_contour[-1], atol=0.005):  # If next_edge starts where the current ends                    add_point_if_new(next_edge[1], current_contour)  # Extend the contour                    edges.pop(i)  # Remove the used edge                    was_extended = True                    break  # Restart looking for the next connecting edge                elif np.allclose(next_edge[1], current_contour[-1], atol=0.005):  # If next_edge ends where the current ends                    add_point_if_new(next_edge[0], current_contour)  # Extend the contour in the reverse direction                    edges.pop(i)  # Remove the used edge                    was_extended = True                    break  # Restart looking for the next connecting edge        contours.extend(current_contour)  # Add the constructed contour    return np.array(contours)  # Convert list of points to an n*2 NumPy array